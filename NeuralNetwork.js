/** * 	Author: 		Lasse Lund Sten Jensen *		Modified: 	2013-02-19 */function NeuralNetwork() {}NeuralNetwork.prototype.create = function(inputs, hiddens, outputs) {	this.inputNeurons  = new Array();	this.hiddenNeurons = new Array();	this.outputNeurons = new Array();					// Create input neurons.	for (var i = 0; i < inputs; i++) {		var neuron = new InputNeuron(i+1);		this.inputNeurons[i] = neuron;		document.getElementById('NeuralNetworkLog').innerHTML += "id->" + neuron.getId() + "<br />";	}					// Create hidden neurons (hidden layer).	for (var i = 0; i < hiddens; i++) {		var neuron = new HiddenNeuron(i+1);		this.hiddenNeurons[i] = neuron;		document.getElementById('NeuralNetworkLog').innerHTML += "id->" + neuron.getId() + "<br />";	}					// Create output neurons.	for (var i = 0; i < outputs; i++) {		var neuron = new OutputNeuron(i+1);		this.outputNeurons[i] = neuron;		document.getElementById('NeuralNetworkLog').innerHTML += "id->" + neuron.getId() + "<br />";	}					// Create links between neurons.	// First layer -> second layer.	for (var i = 0; i < this.inputNeurons.length; i++) {		// For each input neuron create a link to each hidden neuron.		for (var j = 0; j < this.hiddenNeurons.length; j++) {			var newLink = new Link(this.inputNeurons[i], this.hiddenNeurons[j], Math.random());			this.inputNeurons[i].addOutLink(newLink);			this.hiddenNeurons[j].addInLink(newLink);						document.getElementById('NeuralNetworkLog').innerHTML += "created link between (input--hidden): " + this.inputNeurons[i].getId() + "--" + this.hiddenNeurons[j].getId() + " weight->" + newLink.getWeight() + "<br />";		}	}	// Second layer -> third layer.	for (var i = 0; i < this.hiddenNeurons.length; i++) {		// For each hidden neuron create a link to each output neuron.		for (var j = 0; j < this.outputNeurons.length; j++) {			var newLink = new Link(this.hiddenNeurons[i], this.outputNeurons[j], Math.random());			this.hiddenNeurons[i].addOutLink(newLink);			this.outputNeurons[j].addInLink(newLink);						document.getElementById('NeuralNetworkLog').innerHTML += "created link between (hidden--output): " + this.hiddenNeurons[i].getId() + "--" + this.outputNeurons[j].getId() + " weight->" + newLink.getWeight() + "<br />";		}	}}NeuralNetwork.prototype.setInputValues = function(values) {	// Parameter "values" is expected to be an array where indexes correspond to input neuron ids (minus 1).	for (var i = 0; i < this.inputNeurons.length; i++) {		this.inputNeurons[i].setInput(values[i]);		// Activate all inputs and links.		this.inputNeurons[i].activate();		document.getElementById('NeuralNetworkLog').innerHTML += "input value set: " + values[i] + " <br />";	}}NeuralNetwork.prototype.getOutputValues = function() {	var values = new Array();		for (var i = 0; i < this.outputNeurons.length; i++) {		values[i] = this.outputNeurons[i].getValue();	}		return values;}NeuralNetwork.prototype.train = function(inputValues, targetOutputValues) {	var LEARNING_RATE = 0.7;		/**	 * Calculate the errors of each neuron/link.	 */		// Calculate the total sum of errors at each output neuron.	this.setInputValues(inputValues);	var actualOutputValues = this.getOutputValues();		var sumOfErrors = [];	for (var i = 0; i < targetOutputValues.length; i++) {		sumOfErrors[i] = targetOutputValues[i] - actualOutputValues[i];		document.getElementById('NeuralNetworkLog').innerHTML += "sum of errors for output[" + i + "] is: " + sumOfErrors[i] + " <br />";	}		// Calculate the error for each link connecting each neuron for the hidden and input layers.	// Hidden layer.	var errorsHidden = [];	for (var i = 0; i < this.hiddenNeurons.length; i++) {		var outLinks = this.hiddenNeurons[i].getOutLinks();		errorsHidden[i] = 0.0;		for (var j = 0; j < outLinks.length; j++) {			errorsHidden[i] += sumOfErrors[outLinks[j].getOutNeuron().getId()-1] * outLinks[j].getWeight();		}		document.getElementById('NeuralNetworkLog').innerHTML += "error for hidden[" + i + "] is: " + errorsHidden[i] + " <br />";	}	// Input layer.	var errorsInput = [];	for (var i = 0; i < this.inputNeurons.length; i++) {		var outLinks = this.inputNeurons[i].getOutLinks();		errorsInput[i] = 0.0;		for (var j = 0; j < outLinks.length; j++) {			errorsInput[i] += errorsHidden[outLinks[j].getOutNeuron().getId()-1] * outLinks[j].getWeight();		}		document.getElementById('NeuralNetworkLog').innerHTML += "error for input[" + i + "] is: " + errorsInput[i] + " <br />";	}	/**	 * Adjust link weights using backpropagation.	 */		for (var i = 0; i < this.hiddenNeurons.length; i++) {		for (var j = 0; j < this.hiddenNeurons[i].getInLinks().length; j++) {	 		var newWeight = this.hiddenNeurons[i].getInLinks()[j].getWeight() + ( LEARNING_RATE * errorsHidden[i] * this.hiddenNeurons[i].getInLinks()[j].getInNeuron().getValue() );	 		this.hiddenNeurons[i].getInLinks()[j].setWeight(newWeight);//	 		document.getElementById('NeuralNetworkLog').innerHTML += "new in-link weight for hidden[" + i + "] is: " + newWeight + " <br />";	 	}	}	 	for (var i = 0; i < this.outputNeurons.length; i++) {	 	for (var j = 0; j < this.outputNeurons[i].getInLinks().length; j++) {	 		var newWeight = this.outputNeurons[i].getInLinks()[j].getWeight() + ( LEARNING_RATE * sumOfErrors[i] * this.outputNeurons[i].getInLinks()[j].getInNeuron().getValue() );	 		this.outputNeurons[i].getInLinks()[j].setWeight(newWeight);//	 		document.getElementById('NeuralNetworkLog').innerHTML += "new in-link weight for output[" + i + "] is: " + newWeight + " <br />";	 	}	}		}/*NeuralNetwork.prototype.derivative = function(x) {	return (1 / ( 1 + Math.exp(x) )) * (1 - (1 / ( 1 + Math.exp(x) )));		// ds(x)/dx = s(x)*(1-s(x))}*/